; orx - Tutorial config file
; Should be used with orx v.1.3+

[Display]
ScreenWidth   = 320
ScreenHeight  = 480
Title         = Lighting/Shader Tutorial
Smoothing     = false

[Clock]
MainClockFrequency = 30

[Render]
ShowFPS = true

[Lighting]
Radius  = 0.3 ~ 0.7
Color   = (1.0, 1.0, 1.0);(1.0, 0.0, 0.0) # (0.0, 1.0, 0.0) # (0.0, 0.0, 1.0) # (1.0, 1.0, 0.0) # (1.0, 0.0, 1.0) # (0.0, 1.0, 1.0) # (1.0, 1.0, 1.0)

[Input]
SetList = MainInput

[MainInput]
KEY_ESCAPE        = Quit
MOUSE_LEFT        = CreateLight
MOUSE_RIGHT       = ClearLights
MOUSE_WHEEL_UP    = IncreaseRadius
MOUSE_WHEEL_DOWN  = DecreaseRadius
KEY_SPACE         = ToggleAlpha

[Scene]
ChildList = Background # Logo # RegularGenerator # BumpGenerator

[Viewport]
Camera = Camera

[Camera]
; We use the same size for the camera than our display on screen so as to obtain a 1:1 ratio
FrustumWidth  = @Display.ScreenWidth
FrustumHeight = @Display.ScreenHeight
FrustumFar    = 2.0
Position      = (0.0, 0.0, -1.0)

[Physics]
Gravity = (0.0, 9.81, 0.0)

[BackgroundGraphic]
Texture = pixel
Pivot   = center

[LogoGraphic]
Texture = orx.png
Pivot   = center

[DemoiselleGraphic]
Texture = demoiselle.png
Pivot   = center

[FujiGraphic]
Texture = fuji.png
Pivot   = center

[Boat1Graphic]
Texture = boat1.png
Pivot   = center

[Boat2Graphic]
Texture = boat2.png
Pivot   = center

[Lit]
ShaderList = LightShader

[Background]
Graphic       = BackgroundGraphic
Smoothing     = false
Position      = (0, 0, 0.5)
ParentCamera  = Camera
Scale         = 1
Color         = (120, 20, 20)

[Logo@Lit]
Graphic   = LogoGraphic
FXList    = LoopFX
Smoothing = true
Position  = (0, 0, 0.4)

[Regular@Lit]
Graphic   = DemoiselleGraphic; # FujiGraphic # Boat1Graphic # Boat2Graphic
Smoothing = false
LifeTime  = 20

[Bump@Regular]
UseBumpMap  = true

[RegularGenerator]
Spawner   = RegularSpawner
Position  = (600, -150, 0)
Scale     = (-1, 1, 1)

[BumpGenerator]
Spawner   = BumpSpawner
Position  = (-600, 150, 0)

[RegularSpawner]
Object      = Regular
WaveSize    = 1
WaveDelay   = 2.5
ObjectSpeed = (-100, 0, 0)

[BumpSpawner@RegularSpawner]
Object      = Bump
ObjectSpeed = (100, 0, 0)

[LoopFX]
SlotList  = Flip # Rot
Loop      = true

[Flip]
Type        = scale
Curve       = smooth
StartTime   = 0.0
EndTime     = 1.0
StartValue  = (1.0, 1.0, 1.0)
EndValue    = (1.0, -1.0, 1.0)

[Rot@Flip]
Type        = rotation
Curve       = linear
Period      = 3.0
StartValue  = 0
EndValue    = 360 # -360

[LightShader]
Code = "
precision mediump float;
mediump vec2 GetLightVector(int _iIndex)
{
  // Done!
  return vec2((avLightPos[_iIndex].x - gl_FragCoord.x) * fScreenSize, 1.0 - (avLightPos[_iIndex].y + gl_FragCoord.y) * fScreenSize);
}

mediump vec3 GetNormal()
{
  mediump vec3        vNormal;
  const mediump vec3  vHalf = vec3(0.5);

  // Gets raw normal
  vNormal = texture2D(NormalMap, gl_TexCoord[0].xy).rgb;

  // Normalizes it
  vNormal = 2.0 * (vNormal - vHalf);

  // Done!
  return vNormal;
}

mediump vec4 GetLightValue(int _iIndex, vec3 _vNormal)
{
  mediump float fIntensity, fBump;
  mediump vec4  vValue;

  // Gets vector from point to light
  mediump vec2 vLight = GetLightVector(_iIndex);

  // Gets its intensity
  fIntensity = clamp(1.0 - (1.0 / (afLightRadius[_iIndex] * afLightRadius[_iIndex])) * (dot(vLight, vLight)), 0.0, 1.0);

  // Uses bump map? */
  if(UseBumpMap != 0.0)
  {
    // Gets bump coef
    fBump = dot(normalize(vec3(vLight, 0.1)), _vNormal);
  }
  else
  {
    // No bump
    fBump = 1.0;
  }

  // Gets colored light value
  vValue = fIntensity * vec4(fBump * avLightColor[_iIndex], afLightAlpha[_iIndex]);

  // Done!
  return vValue;
}

void main()
{
  mediump vec4 vPixel;

  // Gets current pixel value
  vPixel = texture2D(Texture, gl_TexCoord[0].xy);

  if(vPixel.a > 0.0)
  {
    mediump vec4 vColor = vec4(0.0);
    mediump vec3 vNormal;
    int   i;
    const int iLightNumber = 1;
    
    // Uses bump map?
    if(UseBumpMap != 0.0)
    {
      // Gets normal
      vNormal = GetNormal();
    }
    else
    {
      // Clears normal
      vNormal = vec3(0.0);
    }

    // For all lights
    for(i = 0; i < iLightNumber; i++)
    {
      // Adds its contribution
      vColor += GetLightValue(i, vNormal);
    }

    // Adds ambient
    vColor.rgb += vAmbient;
  
    // Updates output
    gl_FragColor.rgb  = vPixel.rgb * vColor.rgb;
    gl_FragColor.a    = vPixel.a - vColor.a;
  }
  else
  {
    gl_FragColor = vec4(0.0);
  }
}
"
ParamList       = Texture # NormalMap # fScreenSize # vAmbient # avLightPos # afLightRadius # avLightColor # afLightAlpha # UseBumpMap # vSize
fScreenSize     = 0.002; @Display.ScreenHeight
vAmbient        = (0.05, 0.05, 0.05)
avLightPos      = (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0)
afLightRadius   = 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0
avLightColor    = (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0) # (0, 0, 0)
afLightAlpha    = 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0 # 0.0
UseBumpMap      = 1.0
vSize           = (0, 0, 0)
